<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Code Breaker</title>
    <link rel="stylesheet" href="{{ url_for('static', filename='style.css') }}">
    <script src="https://d3js.org/d3.v7.min.js"></script>

</head>
<body>
    <h1>Code Structure Visualizer</h1>

    <form method="post" enctype="multipart/form-data">
        <input type="file" name="file" accept=".py" required>
        <button type="submit">Analyze File</button>
    </form>

    {% if error %}
        <p class="error">Error: {{ error }}</p>
    {% endif %}

    <svg width="960" height="500"></svg>

    <div id="code-display">
        <div id="code-content">Click on a node (class or function) to see its code here.</div>
        <div id="resize-handle"></div>
    </div>

    <script>
        const codeStructure = {{ code_structure_json | safe }};
        const svg = d3.select("svg");
        const width = +svg.attr("width");
        const height = +svg.attr("height");
        const g = svg.append("g").attr("transform", "translate(40,0)"); // Main group for tree
        const linkGroup = g.append("g"); // Group for standard tree links
        const callLinkGroup = g.append("g"); // Group for dynamic call links (DRAW FIRST)
        const nodeGroup = g.append("g"); // Group for nodes (DRAW ON TOP of call links)

        // Map to store nodes by their unique ID for quick lookup
        const nodesById = new Map();

        if (codeStructure && codeStructure.children && codeStructure.children.length > 0 && !codeStructure.error) {
            const treeLayout = d3.tree().size([height, width - 160]); // Adjust width for labels

            const root = d3.hierarchy(codeStructure, d => d.children); // Ensure children accessor is correct
            treeLayout(root);

            // Populate the nodesById map
            root.descendants().forEach(node => {
                if (node.data.id) { // Only map nodes with an ID
                    nodesById.set(node.data.id, node);
                }
            });

            // Standard Tree Links
            linkGroup.selectAll(".link")
                .data(root.links()) // Use root.links() for standard parent-child links
                .enter().append("path")
                .attr("class", "link")
                .attr("d", d3.linkHorizontal()
                    .x(d => d.y) // source/target are properties of link objects
                    .y(d => d.x));

            // Nodes
            const node = nodeGroup.selectAll(".node")
                .data(root.descendants()) // Use root.descendants() for nodes
                .enter().append("g")
                .attr("class", d => "node" + (d.children ? " node--internal" : " node--leaf"))
                .attr("transform", d => `translate(${d.y},${d.x})`)
                .attr("id", d => `node-${d.data.id}`); // Assign ID to the node group

            node.append("circle")
                .attr("r", 10)
                // Add cursor pointer if it's a function/method that could be called or call others
                .style("cursor", d => (d.data.type === 'function' || d.data.type === 'method') ? "pointer" : (d.data.code ? "pointer" : "default"));

            node.append("text")
                .attr("dy", ".35em")
                .attr("x", d => d.children ? -13 : 13) // Position text relative to circle
                .style("text-anchor", d => d.children ? "end" : "start")
                .text(d => `${d.data.name} (${d.data.type || 'module'})`); // Display name and type

            const codeDisplay = d3.select("#code-display");
            const codeContent = d3.select("#code-content");

            // Function to draw call links (showing functions THAT CALL the clicked node)
            function drawCallLinks(clickedNodeData) {
                callLinkGroup.selectAll("*").remove(); // Clear previous call links

                // Iterate through the functions THAT CALL the clicked node
                if (clickedNodeData.called_by && clickedNodeData.called_by.length > 0) {
                    const targetNode = nodesById.get(clickedNodeData.id); // The clicked node is the target
                    if (!targetNode) return;

                    // Define line generator with curve
                    const lineGenerator = d3.line()
                        .x(d => d.y) // Horizontal position from node's y
                        .y(d => d.x) // Vertical position from node's x
                        .curve(d3.curveBumpX); // Apply the curve

                    clickedNodeData.called_by.forEach(callerId => { // Iterate through IDs in the 'called_by' list
                        const callerNode = nodesById.get(callerId); // Node that calls the clicked one
                        const clickedAsSourceNode = targetNode; // The clicked node is the source of the arrow

                        if (callerNode) {
                            try {
                                // Create points array: [clicked_node (source), caller (target)]
                                const points = [clickedAsSourceNode, callerNode];

                                // Generate path data using the curved line generator
                                const pathData = lineGenerator(points);
                                if (!pathData || pathData.includes("NaN")) {
                                    console.error("Invalid path data generated:", pathData, "Points:", points);
                                    return; // Skip if path is invalid
                                }

                                // Append the path WITH marker pointing towards the CALLER node (target)
                                callLinkGroup.append("path")
                                    .attr("class", "call-link")
                                    .attr("d", pathData)
                                    .attr("marker-end", "url(#arrow)");
                            } catch (error) {
                                console.error("Error generating or appending path:", error, "Source:", clickedAsSourceNode, "Target:", callerNode);
                            }
                        } else {
                            console.warn(`Caller node with ID ${callerId} not found in map.`);
                        }
                    });
                }
            }

             // Define arrowhead marker
             svg.append("defs").append("marker")
                .attr("id", "arrow")
                .attr("viewBox", "0 -5 10 10")
                .attr("refX", 15) // Controls the distance of the arrowhead from the line end
                .attr("refY", 0)
                .attr("markerWidth", 6)
                .attr("markerHeight", 6)
                .attr("orient", "auto")
                .append("path")
                .attr("d", "M0,-5L10,0L0,5")
                .attr("class", "arrowhead");


            // Add click listener to nodes
            node.on("click", function(event, d) {
                event.stopPropagation(); // Prevent click from bubbling up

                // --- Selection and Code Display ---
                nodeGroup.selectAll(".node circle").classed("selected", false); // Deselect all
                callLinkGroup.selectAll("*").remove(); // Clear previous call links

                if (d.data.code) {
                    d3.select(this).select("circle").classed("selected", true); // Select clicked
                    codeContent.text(d.data.code);
                    codeDisplay.classed("visible", true); // Show drawer
                } else {
                    codeDisplay.classed("visible", false); // Hide drawer if no code
                }

                // --- Draw Call Links ---
                if (d.data.type === 'function' || d.data.type === 'method') {
                    drawCallLinks(d.data);
                }
            });

            // Add click listener to the body to hide drawer and clear links
            d3.select("body").on("click", function() {
                codeDisplay.classed("visible", false);
                nodeGroup.selectAll(".node circle").classed("selected", false); // Deselect nodes
                callLinkGroup.selectAll("*").remove(); // Clear call links
            });

            // Prevent clicks inside the code display from closing it and clearing links
            codeDisplay.on("click", function(event) {
                event.stopPropagation(); // Keep drawer open when clicking inside
            });

            // --- Drawer Resizing Logic --- (Keep existing logic)
            const drawer = document.getElementById('code-display');
            const handle = document.getElementById('resize-handle');
            let isResizing = false;
            let startX = 0;
            let startWidth = 0;

            handle.addEventListener('mousedown', function(e) {
                isResizing = true;
                startX = e.clientX;
                startWidth = drawer.offsetWidth;
                document.body.style.cursor = 'ew-resize';
                e.preventDefault();
            });

            document.addEventListener('mousemove', function(e) {
                if (!isResizing) return;
                let newWidth = startWidth + (e.clientX - startX);
                // Clamp min/max width
                newWidth = Math.max(200, Math.min(window.innerWidth * 0.9, newWidth));
                drawer.style.width = newWidth + 'px';
            });

            document.addEventListener('mouseup', function(e) {
                if (isResizing) {
                    isResizing = false;
                    document.body.style.cursor = '';
                }
            });
            // --- End Drawer Resizing Logic ---
        } else if (codeStructure && codeStructure.error) {
             g.append("text")
              .attr("x", width / 2)
              .attr("y", height / 2)
              .attr("text-anchor", "middle")
              .attr("class", "error-message") // Style error message
              .text(`Error during analysis: ${codeStructure.error}. Please check the console or file.`);
        } else if (!{{ error | tojson }}) { // Handle case where no file was uploaded yet
             g.append("text")
              .attr("x", width / 2)
              .attr("y", height / 2)
              .attr("text-anchor", "middle")
              .text("Upload a Python file (.py) to see its structure.");
        }

    </script>
</body>
</html>
